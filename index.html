<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Solver</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <div class="container">
        <div class="header">
            <h1>Neural Solver</h1>
            <div class="status-dot"></div>
        </div>

        <!-- Input Section -->
        <textarea id="input" class="neu-inset" placeholder="Enter your request..."></textarea>

        <!-- Controls -->
        <button id="solveBtn" class="neu-btn" onclick="processRequest()">
            SOLVE
        </button>

        <!-- Output Section -->
        <div class="output-wrapper neu-inset">
            <pre id="output"></pre>
        </div>
    </div>

    <script>
        let isProcessing = false;

        function typeWriter(text, elementId) {
            return new Promise((resolve) => {
                const element = document.getElementById(elementId);

                // Настройка скорости:
                // Чем длиннее текст, тем больше символов выводим за 1 раз.
                // Для коротких ответов - по 2 символа, для длинных - по 20+.
                let batchSize = 1;
                if (text.length > 50) batchSize = 3;
                if (text.length > 200) batchSize = 8;
                if (text.length > 500) batchSize = 25;
                if (text.length > 1000) batchSize = 50;

                let i = 0;

                function type() {
                    if (i < text.length) {
                        // Берем сразу кусок текста ("чанк")
                        const chunk = text.slice(i, i + batchSize);

                        // Вставляем кусок
                        element.textContent += chunk;

                        // Увеличиваем счетчик
                        i += batchSize;

                        // Прокрутка вниз
                        element.scrollTop = element.scrollHeight;

                        // Рекурсия с минимальной задержкой
                        // Можно поставить 0 или 10 (для приятной плавности)
                        setTimeout(type, 10);
                    } else {
                        resolve();
                    }
                }
                type();
            });
        }

        async function processRequest() {
            const inputField = document.getElementById('input');
            const outputField = document.getElementById('output');
            const btn = document.getElementById('solveBtn');
            const inputText = inputField.value;

            if (!inputText) return;

            btn.classList.add('processing');
            btn.innerText = "PROCESSING...";
            outputField.textContent = "Accessing Go Backend..."; // Изменили текст
            inputField.disabled = true;
            btn.disabled = true;

            try {
                // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
                // Go функция доступна напрямую как глобальная JS функция
                // Она возвращает Promise, поэтому await работает
                const response = await solveProblem(inputText);

                await typeWriter(response, 'output', 20);

            } catch (error) {
                outputField.textContent = "Error: " + error;
            } finally {
                btn.classList.remove('processing');
                btn.innerText = "SOLVE";
                inputField.disabled = false;
                btn.disabled = false;
                inputField.focus();
            }
        }
    </script>
</body>

</html>