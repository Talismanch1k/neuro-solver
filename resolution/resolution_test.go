package resolution

import "testing"

// помощник для запуска одного тестового случая
func runCase(t *testing.T, name string, clauses []string, want bool) {
	t.Helper()
	engine := NewResolutionEngine()
	engine.ParseInput(clauses)
	res := engine.Prove()
	if res.Success != want {
		t.Fatalf("%s: got Success=%v, want %v\nFullLog:\n%s", name, res.Success, want, res.FullLog)
	}
}

func TestSocrates(t *testing.T) {
	// Нам известно, что все люди смертны и что Сократ — человек.
	// Нужно доказать, что Сократ смертен.
	runCase(t, "Socrates", []string{
		"Человек(Сократ)",
		"¬Человек(x) ∨ Смертен(x)",
		"¬Смертен(Сократ)",
	}, true)
}

func TestRain(t *testing.T) {
	// Если идёт дождь, то место становится мокрым.
	// Известно, что на улице идёт дождь,
	// Нужно доказать, что улица мокрая.
	runCase(t, "Rain", []string{
		"¬Дождь(x) ∨ Мокрая(x)",
		"Дождь(Улица)",
		"¬Мокрая(Улица)",
	}, true)
}

func TestFriends(t *testing.T) {
	// Если A любит B и B любит A, то они считаются друзьями.
	// Дан взаимный факт любви Ромео и Джульетты.
	// Нужно доказать, что Ромео и Джульетта — друзья.
	runCase(t, "Friends", []string{
		"Любит(Ромео, Джульетта)",
		"Любит(Джульетта, Ромео)",
		"¬Любит(x, y) ∨ ¬Любит(y, x) ∨ Друзья(x, y)",
		"¬Друзья(Ромео, Джульетта)",
	}, true)
}

func TestChain(t *testing.T) {
	// У нас есть объект Obj, про который известно, что он обладает свойством A.
	// Также даны цепочки правил: A → B, B → C, C → D.
	// Нужно вывести, что Obj обладает свойством D.
	runCase(t, "Chain", []string{
		"А(Объект)",
		"¬А(x) ∨ Б(x)",
		"¬Б(x) ∨ В(x)",
		"¬В(x) ∨ Г(x)",
		"¬Г(Объект)",
	}, true)
}

func TestViking(t *testing.T) {
	// Известно: любой викинг храбр, а любой храбрый попадает в Вальгаллу.
	// Также дан факт: Рагнар — викинг.
	// Нужно доказать, что Рагнар попадает в Вальгаллу.
	runCase(t, "Viking", []string{
		"¬Викинг(x) ∨ Храбр(x)",
		"¬Храбр(x) ∨ ПопадаетВВальгаллу(x)",
		"Викинг(Рагнар)",
		"¬ПопадаетВВальгаллу(Рагнар)",
	}, true)
}

func TestAncestryComplex(t *testing.T) {
	// «Есть цепочка родительских отношений: Абрам→Борис→Виктор→...
	// Также известно, что родитель порождает отношение «предок»
	// Доказать: Предок(Абрам, Ефрем).»
	runCase(t, "AncestryComplex", []string{
		"Родитель(Абрам, Борис)",
		"Родитель(Борис, Виктор)",
		"Родитель(Виктор, Геннадий)",
		"Родитель(Геннадий, Дмитрий)",
		"Родитель(Дмитрий, Ефрем)",
		"¬Родитель(x, y) ∨ Предок(x, y)",
		"¬Родитель(x, z) ∨ ¬Предок(z, y) ∨ Предок(x, y)",
		"¬Предок(Абрам, Ефрем)",
	}, true)
}

func TestPathInfection(t *testing.T) {
	// Есть цепочка соединений: Internet → R1 → R2 → ColdStore.
	// Если есть соединение, то существует путь; пути транзитивны.
	// В сети Internet есть заражение, и заражение распространяется по пути.
	// Нужно доказать, что заражён узел ColdStore.
	runCase(t, "PathInfection", []string{
		"Соединение(Internet, R1)",
		"Соединение(R1, R2)",
		"Соединение(R2, ColdStore)",
		"¬Соединение(x, y) ∨ Путь(x, y)",
		"¬Путь(x, y) ∨ ¬Путь(y, z) ∨ Путь(x, z)",
		"Заражен(Internet)",
		"¬Заражен(x) ∨ ¬Путь(x, y) ∨ Заражен(y)",
		"¬Заражен(ColdStore)",
	}, true)
}

func TestComplexNoContradiction(t *testing.T) {
	// Даны соединения A → B и B → C и правило транзитивности пути.
	// Но нет никаких связей с узлом D.
	// Нужно убедиться, что путь A → D вывести невозможно.
	runCase(t, "ComplexNoContradiction", []string{
		"Соединение(A, B)",
		"Соединение(B, C)",
		"¬Путь(x, y) ∨ ¬Путь(y, z) ∨ Путь(x, z)",
		"¬Путь(A, D)",
	}, false)
}

func TestCats(t *testing.T) {
	// Лена любит кошек. По правилу: если кто-то любит кошек, то Вася любит этого человека.
	// Нужно доказать: «Вася любит Лену».
	runCase(t, "Cats", []string{
		"ЛюбитКошек(Лена)",
		"¬ЛюбитКошек(y) ∨ Любит(Вася, y)",
		"¬Любит(Вася, Лена)",
		"¬Любит(Вася, Лена)",
	}, true)
}
func TestArityMismatchPreventsUnify(t *testing.T) {
	// P(x,y) не унифицируется с ¬P(x) — цель Q(A) недостижима.
	runCase(t, "ArityMismatchPreventsUnify", []string{
		"P(A, B)",
		"¬P(A)",
		"¬Q(A)",
	}, false)
}
